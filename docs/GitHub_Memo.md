# GitHub

普段使うGitとGitHubの用語や操作手順についてまとめました．

## 手順

基本的な流れは  
  
リモートリポジトリ作成

クローンしてローカルリポジトリ作成

ブランチ作成

ファイル修正

addで変更をステージに上げる

コミットする

originをmasterにプルする

プッシュする

プルリクエストを出す

マージする

リモートリポジトリのブランチを削除する

ローカルリポジトリでプルする

ローカルリポジトリのブランチを削除する

## リモートリポジトリとローカルリポジトリの作成

Q : リポジトリってなに？

A : リポジトリとはコードの置き場のことです．

GitHubのWebページでリポジトリを作成します．

リポジトリのページの右側にある`Clone or download`をクリックし，URL横のボタンをクリックしてリポジトリのURLをコピーします．

Q : Clone(クローン)ってなに？

A : リモートリポジトリをコピーして，ローカルリポジトリとして自分のPC上に作成することです．変更履歴も複製されるので，元のローカルリポジトリと同じように履歴の参照やコミットをすることができます．zipをダウンロードして展開すると，後述する.gitフォルダが作成されません．

ターミナルを起動し，ローカルリポジトリを作成したいところまでカレントディレクトリを移動します．

ローカルリポジトリはリモートリポジトリをクローンして作成します．

```bash
git clone [リポジトリのURL]
```

でローカルリポジトリを作成します．  
  
この時，リポジトリ名でフォルダが作成されます．  
  
```bash
cd [リポジトリ]
```
  
でリポジトリ内のフォルダに入ります．

```bash
ls -a
```

でフォルダ内のファイルを見ると **.git**フォルダが作られているのが確認できます．
  
Q : **.git**フォルダってなに？  
  
**.git**がローカルリポジトリ．履歴データの保管場所のことです.このフォルダがリモートリポジトリと繋げています．それ以外にもGit関連の設定がすべて入っています．  
  
## ローカルリポでユーザをセット

```bash
git config --global user.name 'ユーザ名'
```  
  
```bash
git config --global user.email 'メールアドレス'
```  

`-global`オプションをつけると他のリポジトリでもデフォルトでユーザがセットされるので毎回ユーザ情報をセットする必要がなくなります． 
  
```bash
git status
```

で今のリポジトリの状態が確認できます．  

変更されたファイルの確認ができます.

ワークツリー⇔ステージ間の変更と，リポジトリ⇔ステージ間の変更の両方を表示しています

```bash
git checkout -b [branch名]
```
  
で新しいブランチを作ります．基本的にmasterでは作業しないので新しいブランチを作成して，そこで作業します 

Git 2.23では，

```bash
git switch
```

によりブランチの変更ができるようになりましたが新機能は実験的機能なので今後の変更の可能性があります
これまでは

```bash
git checkout
```

を使っていましたが，checkoutコマンドにできることが多いので変更となります
  
## 変更の保存

 Gitで変更を保存するには，2段階あります．一つはステージで，もう一つはコミットです．ステージで，変更を保存するファイルやフォルダを選んで，コミットで実際に変更を保存するという流れになります．

 Q : ステージってなに？

 A : 次のコミット対象に入れる行為

 Q : コミットってなに？

 A : セーブポイントみたいなもの
  
```bash
git add .
```
  
で変更内容をステージに上げます  

個別に変更をステージに上げるには

```bash
git add [ファイル名またはフォルダ名]
```

を使います．
  
```bash
git status
```  
  
でstageに変更内容が上がってるか確認します  
  
```bash
git commit -m "[comment]"
```
  
で，リモートリポにコミットします．変更内容をコメントでわかりやすく記述します  
  
```bash
git status  
```  

でリポジトリの状態を確認できます  
  
```bash
git log
```  
  
でログを確認  
  
```bash
git pull origin master  
```  

でリモートリポの変更をローカルリポに反映させます  
  
```bash
git push origin [branch名]
```  
  
でローカルリポの変更をリモートリポに送ります．

```bash
git push origin HEAD
```

とするとブランチ名を指定しなくてもカレントブランチをリモートにpushすることができる．

```bash
git push [リモート名] [branch名]
```  

`origin`はリモートリポジトリのショートカット名
  
WebサイトのGitHubのリポジトリのページに行き，  
  
`compare & pull request`をクリックします  
  
`Write`にコメントを書いて，`Create pull request`をクリックします．  
  
`Merge pull request`をクリックします．  
  
`Confirm merge`をクリックします
  
## 新しいブランチを作成

Gitではそれぞれのバージョンを直接変更するのではなく、ひとまずブランチとして管理します．  
  
基本的には開発したい機能ごとにブランチを作っていきます  
  
開発者はブランチを切り替えて適切なブランチの上で作業します  
  
ブランチを切り替えることを**checkout**するといいます  
  
```bash
git branch
```

ブランチの一覧を表示します，  
  
*がついている場所が自分のいるブランチです．
  
```bash
git checkout -b [branch名]  
```  

新しいブランチを作成  
  
基本的にmasterでは作業しません  
  
```bash
git status  
```  

で今のリポジトリの状態を表示します  

コミット対象の変更群  
  
ステージにaddされた変更だけがコミットできます

コミットされて初めて変更がリポジトリに反映されます

```bash
git add [ファイル名]
```  
  
変更したファイルをステージにあげます

```bash
git add .  
```  

カレントディレクトリ以下のすべての変更をステージにあげることができます  
  
```bash
git add [ファイル名]  
```  

で指定したファイルのみステージにあげます  
  
```bash
git add
```

により，変更したファイルの圧縮ファイルがローカルリポジトリに作成され，同時にステージにインデックスが作成されます

```bash
git commit -m '[変更内容のコメント]'
```  

ステージに上がっているすべての変更をコミットします  
  
変更を記録することをコミットと呼びます
  
何を変更したかわかるようにコメントを残します  
  
```bash
git log  
```  

変更履歴の確認
  
### pushする前に必ずpullする

Q : フェッチってなに？
  
A : データを取ってくること  
  
Q : マージってなに？
  
あるブランチを別のブランチにマージすること
  
Q : プルってなに？  
  
リモートリポからフェッチして，自分のリポにマージするという二つのことを行います  
  
```bash
git pull origin master  
```  

リモートリポジトリのoriginをmasterにプルします．
  
```bash
git remote -v  
```  

リポジトリ名の確認　基本的にoriginなので確認しなくてよいです  
  
```bash
git push [リポジトリ名][branch名]  
```  

githubのページでプルリクエストを承認します．同時に，リモートリポジトリのブランチを削除します．
  
## ローカルリポをpull
  
```bash
git pull origin master
```
でローカルリポジトリのmasterをリモートリポジトリのoriginと同じ状態にします  
  
```bash
git branch -d [ブランチ名]
```
で，ブランチを削除します

## リセット

```bash
git reset HEAD [ファイル名]  
```

 ステージした変更を取り消します．  

 ワークツリーには影響しません．直前のcommitでstagingを上書きしています．  

 `HEAD`は今自分のいるbranchの最新のcommitのこと  

```bash
git reset --soft HEAD^
```

commitのみ取り消します．変更はステージングされた状態で残っています．  
  
```bash
git reset HEAD^  
```  

commitとstagingが取り消されます．  
  
```bash
git reset --hard HEAD^  
```

コミット，ステージ，変更そのものが取り消され，前回のコミットから何も変更されていない状態に戻ります．  
  
[参考]<https://qiita.com/sahara/items/f6ab19fec79027379820>

```bash
git diff [ファイル名]
```  
  
ワークツリーとステージ間の変更差分を確認します  
`--staged`をつけることで stagingされたファイルとリポジトリ間の変更差分を確認できます．

## エイリアス

```bash
git config --global alias.ci commit  
git config --global alias.st status  
git config --global alias.br branch  
git config --global alias.co checkout  
```

## 変更を取り消す

```bash
git restore [ファイル名]  
```

変更を取り消す．ワークツリーの状態をステージの状態と同じにするという動作.`--`がついているのはファイル名をbranch名と区別するため  
  
```bash
git restore --staged [ファイル名]  
```  

ステージした変更を取り消します．  
  
```bash
git commit --amend  
```  

直前のcommitを取り消します．

## リモートリポジトリ

```bash
git remote -v  
```  

対応するURLを表示します．

## branch

`HEAD`は自分が今いるブランチを指しています.
`branch`はブランチ内の最新のコミットを指しています．

## ファイルを追跡しないための.gitignore

テキストエディタで`.gitignore`ファイルを作成し，中にファイル名を書き込むと変更してもgitに追跡されません．

## merge

maergeとは，ほかの人の変更内容を取り込む作業のことです  
  
```bash
git merge [branch名]  
git merge [remote名/branch名]
```  

## mergeには3種類あります

- Fast Forward : 早送りになるmerge branchが枝分かれしていなかったときは，branchのポインタを前に進めるだけ
- Auto Merge : 基本的なmerge 枝分かれして開発していた場合，merge commitという新しいcommitを作ります
- Confrict 同じファイルの同じ行に対して異なる編集を行ったときに起こります
- コンフリクトの解決の仕方
ファイル内の<<<<<<HEADと====と>>>>branch名を削除して，ファイルの内容を書き換えます

## コンフリクト防止するには

- 複数人で同じファイルを変更しない
- pullやmergeする前に変更中の状態をなくしておく(commitやstashをしておく)>>変更中のファイルがあると，pullやmergeでエラーがでます
- pullするときは，pullするbranshに移動してからpullする
- コンフリクトしても慌てない

## ブランチを利用した開発の流れ

- masterブランチをリリース用ブランチに，開発はトピックごとにトピックブランチを作成して進めるのが基本

## プルリクエストの流れ

- プルリクエストは，自分の変更したコードをリポジトリに取り込んでもらえるよう依頼する機能

- かならずレビューを挟みます．okだったらリポジトリに取り込みます

### プルリクエストの手順

- ローカルからGitHubへプッシュ
- プルリクエストを送る
- コードレビュー
- プルリクエストをマージ
- ブランチを削除

## GitHub Flow

- GitHub Flowとは，GitHub社のワークフローのこと

### GitHub Flowの流れ

- masterブランチからブランチを作成
- ファイルを変更し，コミット
- 同名のブランチをGitHubへプッシュ
- プルリクエストを送る
- コードレビューし，masterブランチにマージ
- masterブランチをデプロイ

### GitHub Flowを実践する上でのポイント

- masterブランチは常にデプロイできる状態に保
- 新開発はmasterブランチから新しいブランチを作成してスタート
- 作成した新しいブランチ上で作業しコミットする
- 定期的にPushする
- masterにマージするためにプルリクエストを使う
- 必ずレビューを受ける
- masterブランチにマージしたらすぐにデプロイする←テストとデプロイ作業は自動化

## リベースする

- リベースとは，変更を統合する際に，履歴をきれいに整えるために使うもの
- git rebase [branch名] ブランチの起点となるコミットを別のコミットに移動する．親commitが変わる．マージと違って，元のブランチが消えて枝分かれが無くなり一直線になる

## リベースでしてはいけないこと

- GitHubにプッシュしたコミットをリベースするのはNG
- GitHubにプッシュしたコミットをリベースすると・・・push出来なくなる．コミットは前のcommitと連鎖しているので，既にプッシュしたコミットをリベースしてしまうと連鎖が違ってしまう
- git push -fは絶対NG　Gitの履歴が完全に壊れてしまう

## マージを使うかリベースを使うか

### マージ

- コンフリクトの解決が比較的簡単
- マージコミットがたくさんあると履歴が複雑化する

- 作業の履歴を残したいならマージを使う

### リベース

- 履歴をきれいに保つことができる
- コンフリクトの解決が若干面倒（コミットそれぞれに解消が必要）
  
- 履歴をきれいにしたいならリベースを使う

### まとめ

- プッシュしていないローカルの変更にはリベースを使い，プッシュした後はマージを使う
- コンフリクトしそうならマージを使う

## プルにはマージ型とリベース型がある

- git pull --rebase origin master だと，マージコミットが残らない

- プルをリベース型に設定するには
- git config --global branch.master.rebase true

## コミットの指定方法

- HEAD^ 1番目の親コミットを指定する

## コミットをまとめる

- git rebase -i HEAD
- まとめたいコミットのpickをsquashに変更

## タグ

- タグとは，コミットを参照しやすくするために分かりやすい名前を付けるもの．リリースポイントに良く使われます
- 注釈付き(annotated)版と軽量(lightweight)版の2種類がある
- git tag -a [タグ名] -m "[メッセージ]
- -aは注釈付きタグを作成するというオプション
- git tag [タグ名]　で軽量版タグ
- git show [タグ名]　でタグのデータを表示する

- タグをリモートに送信するにはgit pushコマンドで別途指定する必要がある
- git push [リモート名] [タグ名]
- git push origin --tags
- --tags でタグを一斉送信

## stash

- 作業が途中でコミットしたくないけど，別のブランチで作業しないといけない．そういう時に作業を一時避難する．
- git stash
- stash は隠すという意味
- ワークツリーやステージの変更をstashという場所に避難させる

### 避難した作業を確認する

- git stash list

### 避難した作業を復元する

- git stash apply
- git stash apply --index ステージの状況も復元する

#### 特定の作業を復元する

- git stash apply [stash名]

#### 避難した作業を削除する

- git stash drop　最新の作業を削除
- git stash drop [スタッシュ名]　特定の作業を削除
- git stash clear 全作業を削除



## 疑問

## 参考文献

- Git超入門講座
<https://datawokagaku.com/category/%E8%AC%9B%E5%BA%A7%E4%B8%80%E8%A6%A7/git%E8%B6%85%E5%85%A5%E9%96%80%E8%AC%9B%E5%BA%A7/>

- Git： もう怖くないGit！チーム開発で必要なGitを完全マスター (Udemy講座)
<https://www.udemy.com/course/unscared_git/>