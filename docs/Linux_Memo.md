# Linux メモ

- WSLでUbuntuを使う
<https://www.atmarkit.co.jp/ait/articles/1903/18/news031.html>

## Linux コマンド

ls -ltr timestampで昇順に表示 一番最近のファイルを確認したいときによく使う
https://github.com/koki534/Memo.githttps://github.com/koki534/Memo.git
cp -p ファイルのパーミッション，所有者情報，タイムスタンプを保持　cpを使うときは基本的に-pを付ける

su - ハイフンを付けるとルートユーザ特有の設定を読み込んでくれるのでなるべく付ける　suだけでもrootユーザになれる





## Shell Script

## shell scriptとは

- Linux OSを操作するための簡易なプログラミング言語
- カーネルに対して命令する
- bash

## サポートしているシェルを一覧表示

```bash
cat /etc/shells
```

## 使われているシェルの確認

```bash
echo $SHELL
```

## 環境変数

$が環境変数であることの目印

### 環境変数の作成

```bash
export AGE=20
```

環境変数の表示
```bash
echo $age
```
## ファイル作成(viコマンドでファイル名末尾に.shを付ける)

↓ファイルの中身

```bash
#! /bin/bash #1行目でシェルの場所を指定する

echo 'Hello World' #Hello World表示
#コメント文は#を文頭に記載
exit 0 #処理終了，それ以外は異常終了
```

## 実行

```bash
chmod 755 ファイル名 #パーミッション変更
```

ファイルに実行するための権限をつける

```bash
./[ファイル名.sh] #シェルスクリプトの実行
```

## 変数

```bash
var1='変数1'
```

変数の宣言

```bash
var2=`command`  #コマンドの実行結果を変数に格納バッククォートで囲む`.var3=$(command)`も同じ
```

```bash
echo $var1
```

変数の中身を取り出す場合は$を付ける

### システム変数の表示

システム変数は初めから定義されている変数
&BASH,$BASH_VERSION,$HOME,$PWD #システム変数

## 配列

### 配列の作成

```bash
fruits=('banana''apple'grape')
```

### 配列の表示方法

```bash
echo "${fruits[@]}"  #配列の中の値を全て表示
echo "${fruits[0]}"  #インデックス0の要素を表示
echo "${!fruits[@]}" #インデックスを表示
echo "${#fruits[@]}" #配列の要素数を表示

fruits[3]='lemon' #配列のインデックス3にlemonを追加
unset fruits[2] #配列のインデックス2を削除
```

## 引数

実行する際に，シェルに渡す値

```bash
./〇〇.sh a b  #このa,bがそれぞれ第1引数，第2引数
```

```bash
echo $1 $2 $2  #第1引数，第2引数，第3引数を表示
```

```bash
echo $0  #シェルスクリプトのファイル名
```

```bash
echo $@  #全引数を表示
```

```bash
echo $#  #引数の数を表示
```

```bash
$?
```

直前に実行したコマンドの戻り値(成功の場合0)

シェルスクリプトから別のシェルスクリプトを呼び出すことも可能

## 標準入出力

- 標準入力 : ターミナルから値を読み取って，それを変数に格納すること readコマンド
- 標準出力 : ターミナル上に値を表示すること echoコマンド

```bash
read var #標準入力
echo var1 =$var  #入力結果表示
```

```bash
read -p 'var1:'var1  #文字付の標準入力
read -sp 'password:'password  #シークレットモードでの標準入力
read -a names  #配列(Array)入力
```

## ファイル出力

実行結果をファイルに書き込むこと
`>:上書き`

```bash
echo 'hello' > hello.txt  #現在いるディレクトリのhello.txtファイルを作成(上書き)してhelloを書き込む
```

`>>: 追記`  

```bash
echo 'hello' >> hello.txt  #現在いるディレクトリのhello.txtファイルを作成(追記)してhelloを書き込む
```

## if文

1. if test 条件文; 2. if [ 条件文 ]; 3. if [[ 条件文]]；

```bash
if test 条件文; or [ 条件文 ]; or [[ 条件文 ]];  #ifの条件文を満たしていない場合に実行される
then
    プログラム  #elifの条件文を満たす場合に処理が実行される
else
    プログラム  #ifもelifも満たさない場合に実行される
fi

=!!  #文字列で等しいか等しくないか
-eq(=), -ne(!=), -le(<=), -gt(>), -ge(>=)  #数値比較
```

le -> less than
ge -> greater than

### if文の and or

条件文1 and 条件文2の場合，条件文1,条件文2を両方満たす場合に実行
書き方は以下の4通り

```bash
if [ 条件文1 ] && [ 条件文 ];
if [ 条件文1 -a 条件文2 ];
if [[ 条件文1 && 条件文2 ]];
if test 条件文1 && 条件文2;
```

条件文1 or 条件文2の場合，条件文1,条件文2のどちらかを満たす場合に実行
書き方は以下の4通り

```bash
if [ 条件文1 ] || [ 条件文 ];
if [ 条件文1 -o 条件文2 ];
if [[ 条件文1 || 条件文2 ]];
if test 条件文1 || 条件文2;
```

否定を表す条件文(3つ)
if ! test 条件文, if[ ! 条件文], if [[ ! 条件文]]

```bash
cmd1 && cmd2  #cmd1が正しく実行されたらcmd2を実行
cmd1 || cmd2  #cmd1がエラーならcmd2を実行
cmd1 && cmd2 || cmd3  #cmd1が正しく実行されたらcmd2が実行されて，cmd1がエラーならcmd3を実行
```

## ファイルの存在チェック

```bash
if [ -e ファイル名 ];  #ファイルもしくはディレクトリの存在確認
then
else
fi

if [ -f ファイル名 ]  #ファイルが存在しディレクトリでなくファイル
if [ -d ファイル名 ] #ディレクトリが存在するか
if [ -s ファイル名 ];  #ディレクトリ or 中身のあるファイルか
if [ -w ファイル名];  #書き込み権限あるか
if [ -x ファイル名];  #実行権限あるか
if [ fileA -nt fileB ]  #fileAがfileBより新しいか
if [ fileA -ot fileB ]  #fileAがfileBより古いか

```bash
#!/bin/bash

if [ -e 'sample' ];
then
        echo 'sampleが存在します'
fi
```



```bash
#!/bin/bash

#if [ -e 'sample' ];  #ディレクトリ or ファイル
#if [ -d 'sample' ]  #ディレクトリ
if [ -f 'sample' ];  #ファイルの場合中の処理を実行
then
        echo 'sampleが存在します'
        rm sample
fi
```

sampleがある場合削除する



## フォルダのフラット化

https://chiilabo.com/2020/09/mac-subfolder-flatten-automator-quick-action/



下位フォルダのすべてのファイルを一箇所のフォルダに移動する操作のことを、「ディレクトリ構造のフラット化」と呼ぶ。　日本語だと検索しづらいが、「flatten folder」などと検索すると検索しやすい。



```bash
find . -mindepth 2 -type f -exec mv -i '{}' . ';'
```

`find .`　：カレントディレクトリの検索

`-mindepth 2`：検索対象を2階層に制限

`-type -f` ：検索対象をファイルに制限

`-exec <コマンド> <オプション> {} ;`：検索したファイルに対して処理をするコマンドを指定して実行

`{}` :検索結果のファイルやディレクトリのパスが入り、指定したコマンドの引数として渡される

`;`：コマンドの終了を示す。

`mv -i` :-iを付けると上書きされる場合は確認メッセージを表示 interectiveの意味



parent_dir オリジナル

parent_dir_1 上記の通り実行　狙い通り親フォルダにファイルが集まった。

parentdir_2 {}のみ''を外す  問題なし

parent_dir_3 ;のみ''を外す エラー発生 find: -exec: no terminating ";" or "+"

parent_dir_4 cd  ';'を\;に書き換える 問題なし



## 空のフォルダをまとめて削除する

```bash
find . -type d -empty -delete
```





# Linux

### メモ
    - WSLでUbuntuを使う
[https://www.atmarkit.co.jp/ait/articles/1903/18/news031.html](https://www.atmarkit.co.jp/ait/articles/1903/18/news031.html)<br>
    - 基本的に一般ユーザを使う

# Linux基礎

### Linuxのディレクトリの特徴
    - ドライブがない
    - 区切り文字は「/」
    - 最上位階層は/(ルート)
    - ホームディレクトリ：ユーザごとの基本ディレクトリ
    - カレントディレクトリ：現在作業中のディレクトリ

### Linuxの主要ディレクトリ
    - /bin : 基本コマンドを格納
    - /boot : LinuxカーネルなどOS起動に必要なファイル配置
    - /dev : HDD・キーボードなどのデバイスを配置　linuxではデバイスもファイル扱いされている
    - /etc : 差字マナ設定ファイルが配置
    - /home/(ユーザ名) : 一般ユーザのホームディレクトリ
    - /lib : /binや/sbinのコマンドを実行に必要なファイル配置
    - /lost+found : バックアップや復元用のファイルが格納
    - /media : リムーバブルディスクのマウントポイント
    - /mnt : 一時的なマウントポイント
    - /opt : パッケージ管理システムのインストール先
    - /proc : プロセスのIDのついたディレクトリが配置
    - /root : rootユーザーのホームディレクトリ
    - /sbin : システム管理者用のコマンドが配置
    - /sr  : FTP，WWWなどで利用するユーザー用のスペース
    - /sys : 主にdeviceやmoduleに各種情報が保存
    - /tmp : メモリ上の一時ファイルを保存
    - /user : ユーザー共有するプログラム・ライブラリのデータ
    - /var : ログ・キャッシュなどの保存場所

### プロセス
    - Linux上で動作中のプログラムやサービス
    - psコマンドで確認可能
            - ps axで，プロセスが全て表示される

### シグナル
    - Linuxのカーネルがプロセスに送る信号
    - 良く使うシグナルの例
            - CTRL+C : SIGINTというシグナル(プロセスが終了)
            - CTRL+Z : SIGTSTPシグナル(プロセスの一時停止)

### ジョブ
    - 複数のプロセスの集まり
            - sleep 10; sleep10   : sleep 10を2回実行
### ジョブの状態
    - フォアグランド
            - シェルを通じて入力を受けるジョブ状態
            - 1ターミナルでは一つのみ
            - CTRL+Zで停止状態へ
    - バックグラウンド
            - キーボードと関連なく背後で動いているジョブ
            - `コマンド &` というように&を付けるとバックグラウンドでジョブが起動する
    - 停止状態
            - 起動しているが一時停止している

kill {プロセスID}で指定したプロセスを終了させられる<br>

### ストリーム
    - LinuxなどUnix系OSではデータの流れを指す言葉
    - データの読み書きを抽象化した概念
    - 入力ストリーム : プロセスに対してデータを入力
    - 出力ストリーム : プロセスから外部に対しデータを出力

### ファイルストリーム
    - プロセスがファイルの内容にアクセスする場合
    - カーネルはファイルに繋がるストリームを作る
    - 入力ストリームが読み込み，出力ストリームが書き込み

### デバイス関連のストリーム
    - ハードディスクやキーボードのようなハードウェアもストリームに組み込まれる
    - ファイルの場合とまったく同じ操作で行える

### プロセス間通信とパイプ
    - プロセス間通信 : プロセス同士をストリームでつないで通信
    - パイプ : プロセス間をつなぐストリーム
    - Linuxでは「|」記号で表す

### 標準入力と標準出力
    - ストリームの種類
            - 標準入力 : データの入力元
            - 標準出力 : 標準出力
            - 標準エラー出力 : エラーが発生した場合のメッセージ
    - Linuxストリームの種類 : 番号で識別
            - 0 : 標準入力 (デフォルト : キーボード)
            - 1 : 標準出力 (デフォルト : 端末画面)
            - 2 : 標準エラー出力 (デフォルト : 端末画面)

### パイプの利用例
    - {コマンド名} | more  : コマンドの結果をページごとに表示
    - ps -aux |  more : プロセスの一覧を一画面ごとに表示
            - ps -aux : プロセスの一覧を取得
            - more : テキストファイルを1画面ずつ表示するコマンド
    
    - リダイレクト : コマンドの入出力をファイルに切り替える機能
            - <や>，>>を使う




# Linux コマンド

whoami : ユーザーが自分はだれかを尋ねるコマンド<br>

groups : ユーザーが所属するグループを調べる<br>

hostname : ホスト名を調べる<br>

ls -ltr timestampで昇順に表示 一番最近のファイルを確認したいときによく使う<br>

cp -p ファイルのパーミッション，所有者情報，タイムスタンプを保持　cpを使うときは基本的に-pを付ける<br>

su - ハイフンを付けるとルートユーザ特有の設定を読み込んでくれるのでなるべく付ける　suだけでもrootユーザになれる<br>

rm - rf (ディレクトリ名) : フォルダの削除<br>

chmod {アクセス権限} {ファイル名}<br>
### vi
:q セーブせずに終了<br>
:q! 変更した業もセーブせずに終了<br>
:w セーブするが終了しない<br>
:wq セーブして終了<br>
Escキー : コマンドモードと編集モードの切り替え<br>

## Shell Script

## shell scriptとは

    - Linux OSを操作するための簡易なプログラミング言語
    - bash

## サポートしているシェルを一覧表示

- bash
    - cat /etc/shells


## ファイル作成(viコマンドでファイル名末尾に.shを付ける)

↓ファイルの中身<br>

- bash
    - #! /bin/bash #1行目でシェルの場所を指定する
    - echo 'Hello World' #Hello World表示
    - #コメント文は#を文頭に記載
    - exit 0 #処理終了，それ以外は異常終了

## 実行

- bash
    - chmod 755 ファイル名 #パーミッション変更

ファイルに実行するための権限をつける<br>

- bash
    - ./[ファイル名.sh] #シェルスクリプトの実行


## 変数

- bash
    - var1='変数1'


変数の宣言<br>

- bash
    - var2=`command`  #コマンドの実行結果を変数に格納バッククォートで囲む`.var3=$(command)`も同じ


- bash
    - echo $var1

変数の中身を取り出す場合は$を付ける<br>

## システム変数の表示

システム変数は初めから定義されている変数<br>
&BASH,$BASH_VERSION,$HOME,$PWD<br>

## 配列

# 配列の作成

- bash
    - fruits=('banana''apple'grape')


# 配列の表示方法

- bash
    - echo "${fruits[@]}"  #配列の中の値を全て表示
    - echo "${fruits[0]}"  #インデックス0の要素を表示
    - echo "${!fruits[@]}" #インデックスを表示
    - echo "${#fruits[@]}" #配列の要素数を表示
    - fruits[3]='lemon' #配列のインデックス3にlemonを追加
    - unset fruits[2] #配列のインデックス2を削除


 引数<br>

実行する際に，シェルに渡す値<br>

- bash
    - ./〇〇.sh a b  #このa,bがそれぞれ第1引数，第2引数

- bash
    - echo $1 $2 $2  #第1引数，第2引数，第3引数を表示

- bash
    - echo $0  #シェルスクリプトのファイル名

- bash
    - echo $@  #全引数を表示


- bash
    - echo $#  #引数の数を表示

- bash
    - $?

直前に実行したコマンドの戻り値(成功の場合0)<br>

シェルスクリプトから別のシェルスクリプトを呼び出すことも可能<br>

## 標準入出力

    - 標準入力 : ターミナルから値を読み取って，それを変数に格納すること readコマンド
    - 標準出力 : ターミナル上に値を表示すること echoコマンド

- bash
    - read var #標準入力
    - echo var1 =$var  #入力結果表示

- bash
    - read -p 'var1:'var1  #文字付の標準入力
    - read -sp 'password:'password  #シークレットモードでの標準入力
    - read -a names  #配列(Array)入力

## ファイル出力

実行結果をファイルに書き込むこと<br>
`>:上書き`<br>


- bash
    - echo 'hello' > hello.txt  #現在いるディレクトリのhello.txtファイルを作成(上書き)してhelloを書き込む

`>>: 追記`<br>

- bash
    - echo 'hello' >> hello.txt  #現在いるディレクトリのhello.txtファイルを作成(追記)してhelloを書き込む

## if文

    - 1. if test 条件文; 2. if `[ 条件文 ]`; 3. if   条件文；

- bash
    - if test 条件文; or `[条件文 ]`; or [[ 条件文 ]];  #ifの条件文を満たしていない場合に実行される
    - then
    -    プログラム  #elifの条件文を満たす場合に処理が実行される
    - else
    -    プログラム  #ifもelifも満たさない場合に実行される
    - fi
    - =!!  #文字列で等しいか等しくないか
    - -eq(=), -ne(!=), -le(<=), -gt(>), -ge(>=)  #数値比較

le -> less than<br>
ge -> greater than<br>

## if文の and or

条件文1 and 条件文2の場合，条件文1,条件文2を両方満たす場合に実行<br>
書き方は以下の4通り<br>

- bash
    - if [ 条件文1 ] && [ 条件文 ];
    - if [ 条件文1 -a 条件文2 ];
    - if [[ 条件文1 && 条件文2 ]];
    - if test 条件文1 && 条件文2;

条件文1 or 条件文2の場合，条件文1,条件文2のどちらかを満たす場合に実行<br>
書き方は以下の4通り<br>

- bash
    - if [ 条件文1 ] || [ 条件文 ];
    - if [ 条件文1 -o 条件文2 ];
    - if [[ 条件文1 || 条件文2 ]];
    - if test 条件文1 || 条件文2;

否定を表す条件文(3つ)<br>
if ! test 条件文, if`[ ! 条件文],` if   ! 条件文<br>

- bash
    - cmd1 && cmd2  #cmd1が正しく実行されたらcmd2を実行
    - cmd1 || cmd2  #cmd1がエラーならcmd2を実行
    - cmd1 && cmd2 || cmd3  #cmd1が正しく実行されたらcmd2が実行されて，cmd1がエラーならcmd3を実行


## ファイルの存在チェック

- bash
    - if [ -e ファイル名 ];  #ファイルもしくはディレクトリの存在確認
    - then
    - else
    - fi
    -  
    - if [ -f ファイル名 ]  #ファイルが存在しディレクトリでなくファイル
    - if [ -d ファイル名 ] #ディレクトリが存在するか
    - if [ -s ファイル名 ];  #ディレクトリ or 中身のあるファイルか
    - if [ -w ファイル名];  #書き込み権限あるか
    - if [ -x ファイル名];  #実行権限あるか
    - if [ fileA -nt fileB ]  #fileAがfileBより新しいか
    - if [ fileA -ot fileB ]  #fileAがfileBより古いか

- bash
    - #!/bin/bash
    -  
    - if [ -e 'sample' ];
    - then
    -        echo 'sampleが存在します'
    - fi

- bash
    - #!/bin/bash
    -  
    - #if [ -e 'sample' ];  #ディレクトリ or ファイル
    - #if [ -d 'sample' ]  #ディレクトリ
    - if [ -f 'sample' ];  #ファイルの場合中の処理を実行
    - then
    -        echo 'sampleが存在します'
    -        rm sample
    - fi


sampleがある場合削除する<br>

## Case文
ある変数を評価して，値に応じて処理を変える<br>

- bash
    - var2=$2
    - case $var2$ in
    - [a-z])
    - echo 'a-zまでの値です';;
    - [A-Z])
    - echo 'A-Zまでの値です';;
    - [0-9])
    - echo '数値です';;
    - esac

## アクセス権(パーミッション)
r(4)読み取り<br>
w(2)書き込み<br>
x(1)実行<br>
5 -> 4+1 読み取り+実行<br>
-rwxrw-r--<br>
↑左から所有者，所有グループ，その他のユーザのアクセス権<br>
